// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: blogs.sql

package database

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const createBlog = `-- name: CreateBlog :one
insert into blogs(
    id, 
    title, 
    author_id, 
    thumbnail_url, 
    content, 
    category, 
    created_at, 
    updated_at
)
values (
    gen_random_uuid(),
    $1,
    $2,
    $3,
    $4,
    $5,
    NOW(),
    NOW()
)
returning id, title, author_id, thumbnail_url, content, created_at, updated_at, category
`

type CreateBlogParams struct {
	Title        string
	AuthorID     uuid.UUID
	ThumbnailUrl string
	Content      string
	Category     uuid.UUID
}

func (q *Queries) CreateBlog(ctx context.Context, arg CreateBlogParams) (Blog, error) {
	row := q.db.QueryRowContext(ctx, createBlog,
		arg.Title,
		arg.AuthorID,
		arg.ThumbnailUrl,
		arg.Content,
		arg.Category,
	)
	var i Blog
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.AuthorID,
		&i.ThumbnailUrl,
		&i.Content,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Category,
	)
	return i, err
}

const deleteBlog = `-- name: DeleteBlog :one
delete from blogs where id = $1
returning id, title, author_id, thumbnail_url, content, created_at, updated_at, category
`

func (q *Queries) DeleteBlog(ctx context.Context, id uuid.UUID) (Blog, error) {
	row := q.db.QueryRowContext(ctx, deleteBlog, id)
	var i Blog
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.AuthorID,
		&i.ThumbnailUrl,
		&i.Content,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Category,
	)
	return i, err
}

const editBlog = `-- name: EditBlog :one
update blogs set title = $1, thumbnail_url = $2, content = $3, category = $4, updated_at = NOW() where id = $5
returning id, title, author_id, thumbnail_url, content, created_at, updated_at, category
`

type EditBlogParams struct {
	Title        string
	ThumbnailUrl string
	Content      string
	Category     uuid.UUID
	ID           uuid.UUID
}

func (q *Queries) EditBlog(ctx context.Context, arg EditBlogParams) (Blog, error) {
	row := q.db.QueryRowContext(ctx, editBlog,
		arg.Title,
		arg.ThumbnailUrl,
		arg.Content,
		arg.Category,
		arg.ID,
	)
	var i Blog
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.AuthorID,
		&i.ThumbnailUrl,
		&i.Content,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Category,
	)
	return i, err
}

const getAuthorNameByBlogId = `-- name: GetAuthorNameByBlogId :one
select username from users join blogs on users.id = blogs.author_id where blogs.id = $1
`

func (q *Queries) GetAuthorNameByBlogId(ctx context.Context, id uuid.UUID) (string, error) {
	row := q.db.QueryRowContext(ctx, getAuthorNameByBlogId, id)
	var username string
	err := row.Scan(&username)
	return username, err
}

const getBlogById = `-- name: GetBlogById :one
select blogs.id, 
    blogs.title, 
    blogs.author_id,
    blogs.thumbnail_url,
    blogs.content,
    blogs.category,
    blogs.created_at,
    blogs.updated_at,
    count(likes.blog_id) as likes_count 
    from blogs left join likes on blogs.id = likes.blog_id 
    where blogs.id = $1 group by blogs.id, blogs.title
`

type GetBlogByIdRow struct {
	ID           uuid.UUID
	Title        string
	AuthorID     uuid.UUID
	ThumbnailUrl string
	Content      string
	Category     uuid.UUID
	CreatedAt    time.Time
	UpdatedAt    time.Time
	LikesCount   int64
}

func (q *Queries) GetBlogById(ctx context.Context, id uuid.UUID) (GetBlogByIdRow, error) {
	row := q.db.QueryRowContext(ctx, getBlogById, id)
	var i GetBlogByIdRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.AuthorID,
		&i.ThumbnailUrl,
		&i.Content,
		&i.Category,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LikesCount,
	)
	return i, err
}

const getBlogNameById = `-- name: GetBlogNameById :one
select title from blogs where id = $1
`

func (q *Queries) GetBlogNameById(ctx context.Context, id uuid.UUID) (string, error) {
	row := q.db.QueryRowContext(ctx, getBlogNameById, id)
	var title string
	err := row.Scan(&title)
	return title, err
}

const getBlogsByAuthorId = `-- name: GetBlogsByAuthorId :many
select blogs.id, blogs.title, blogs.author_id, blogs.content, blogs.thumbnail_url, blogs.category, blogs.created_at, blogs.updated_at, count(likes.blog_id) as likes_count from blogs left join likes on blogs.id = likes.blog_id where blogs.author_id = $1 group by blogs.id, blogs.title, blogs.author_id, blogs.thumbnail_url
`

type GetBlogsByAuthorIdRow struct {
	ID           uuid.UUID
	Title        string
	AuthorID     uuid.UUID
	Content      string
	ThumbnailUrl string
	Category     uuid.UUID
	CreatedAt    time.Time
	UpdatedAt    time.Time
	LikesCount   int64
}

func (q *Queries) GetBlogsByAuthorId(ctx context.Context, authorID uuid.UUID) ([]GetBlogsByAuthorIdRow, error) {
	rows, err := q.db.QueryContext(ctx, getBlogsByAuthorId, authorID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetBlogsByAuthorIdRow
	for rows.Next() {
		var i GetBlogsByAuthorIdRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.AuthorID,
			&i.Content,
			&i.ThumbnailUrl,
			&i.Category,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.LikesCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBlogsByCategory = `-- name: GetBlogsByCategory :many
select blogs.id, blogs.title, blogs.author_id, blogs.thumbnail_url, count(likes.blog_id) as likes_count from blogs left join likes on blogs.id = likes.blog_id where blogs.category = $1 group by blogs.id, blogs.title, blogs.author_id, blogs.thumbnail_url
`

type GetBlogsByCategoryRow struct {
	ID           uuid.UUID
	Title        string
	AuthorID     uuid.UUID
	ThumbnailUrl string
	LikesCount   int64
}

func (q *Queries) GetBlogsByCategory(ctx context.Context, category uuid.UUID) ([]GetBlogsByCategoryRow, error) {
	rows, err := q.db.QueryContext(ctx, getBlogsByCategory, category)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetBlogsByCategoryRow
	for rows.Next() {
		var i GetBlogsByCategoryRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.AuthorID,
			&i.ThumbnailUrl,
			&i.LikesCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBlogsByTitle = `-- name: GetBlogsByTitle :many
select id, title, author_id, thumbnail_url from blogs where title = $1
`

type GetBlogsByTitleRow struct {
	ID           uuid.UUID
	Title        string
	AuthorID     uuid.UUID
	ThumbnailUrl string
}

func (q *Queries) GetBlogsByTitle(ctx context.Context, title string) ([]GetBlogsByTitleRow, error) {
	rows, err := q.db.QueryContext(ctx, getBlogsByTitle, title)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetBlogsByTitleRow
	for rows.Next() {
		var i GetBlogsByTitleRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.AuthorID,
			&i.ThumbnailUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNoOfLikes = `-- name: GetNoOfLikes :one
select count(*) from likes where blog_id = $1
`

func (q *Queries) GetNoOfLikes(ctx context.Context, blogID uuid.UUID) (int64, error) {
	row := q.db.QueryRowContext(ctx, getNoOfLikes, blogID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const isBlogLiked = `-- name: IsBlogLiked :one
select user_id, blog_id, created_at, updated_at from likes where user_id = $1 and blog_id = $2
`

type IsBlogLikedParams struct {
	UserID uuid.UUID
	BlogID uuid.UUID
}

func (q *Queries) IsBlogLiked(ctx context.Context, arg IsBlogLikedParams) (Like, error) {
	row := q.db.QueryRowContext(ctx, isBlogLiked, arg.UserID, arg.BlogID)
	var i Like
	err := row.Scan(
		&i.UserID,
		&i.BlogID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const likeBlog = `-- name: LikeBlog :exec
insert into likes (user_id, blog_id, created_at, updated_at)
values ($1, $2, NOW(), NOW())
`

type LikeBlogParams struct {
	UserID uuid.UUID
	BlogID uuid.UUID
}

func (q *Queries) LikeBlog(ctx context.Context, arg LikeBlogParams) error {
	_, err := q.db.ExecContext(ctx, likeBlog, arg.UserID, arg.BlogID)
	return err
}

const unlikeBlog = `-- name: UnlikeBlog :exec
delete from likes where user_id = $1 and blog_id = $2
`

type UnlikeBlogParams struct {
	UserID uuid.UUID
	BlogID uuid.UUID
}

func (q *Queries) UnlikeBlog(ctx context.Context, arg UnlikeBlogParams) error {
	_, err := q.db.ExecContext(ctx, unlikeBlog, arg.UserID, arg.BlogID)
	return err
}
